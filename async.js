// Результат у консолі буде: 
// start,
// 1
// end
// 2

console.log('start'); // start: це перший рядок скрипта, який виконується синхронно.

const promise1 = new Promise((resolve, reject) => {
  console.log(1) // 1: це реєструється всередині Promise функції-конструктора і виконується синхронно.
  resolve(2) // 2: Це реєструється всередині функції колбеку і виконується асинхронно після виконання усього коду.
})

promise1.then(res => {
console.log(res)
})

console.log('end'); // end: це останній рядок сценарію, який виконується синхронно після Promise повернення функції конструктора.


// 2. Результат у консолі буде 2
Promise.resolve(1)
		.then((x) => x + 1) //тут Х став =2
		.then((x) => { throw new Error('My Error') })  //тут Х стає функцією throw new Error('My Error') 
		.catch(() => 1) //тут так як ми спіймали помилку, ми встановили Х значення 1 
		.then((x) => x + 1) //тут ми додали до Х=1 ще 1, тобто Х став =2
		.then((x) => console.log(x)) //тут ми вивели це у когнсоль
		.catch(console.error) //а цей пункт не спрацьовує, тому що у попередньому ми обробили вже помилку, і зробили Х=1


// 3. Результатом буде:
// 2
// 4
// undefined
// 8
const promise = new Promise(res => res(2));
	promise
      .then(v => {
	        console.log(v); // виводить в консоль 2
	        return v * 2; // дає наступному методу далі значення v=4
	    })
	    .then(v => {
	        console.log(v); // виводить в консоль 4
	        return v * 2; // дає наступному методу далі значення v=8
	    })
	    .finally(v => {
	        console.log(v); // finally не може нічого приймати, тому виводить у консоль undefined
	        return v * 2; // це не спрацьовує
	    })
	    .then(v => {
	        console.log(v); // тут ми виводимо v=8, яке нам передав попередній .then
	    });